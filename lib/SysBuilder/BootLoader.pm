######################################################################
# Copyright (c) 2012, Yahoo! Inc. All rights reserved.
#
# This program is free software. You may copy or redistribute it under
# the same terms as Perl itself. Please see the LICENSE.Artistic file 
# included with this project for the terms of the Artistic License
# under which this project is licensed. 
######################################################################

package SysBuilder::BootLoader;

use strict;
use warnings 'all';
use lib '/sysbuilder/lib';
use YAML;
use SysBuilder::Utils qw(:all);
use SysBuilder::Console qw();
use SysBuilder::Proc qw();
use POSIX qw();
use Carp;

sub new {
    my $class  = shift;
    my %params = @_;

    my $cfg = $params{cfg} || YAML::LoadFile("/sysbuilder/etc/config.yaml");
    my $fs_out = $params{fs_out} || "/sysbuilder/etc/filesystems.yaml";
    my $proc   = $params{proc}   || ( SysBuilder::Proc->new );
    my $fs;

    eval { $fs = YAML::LoadFile($fs_out); };
    if ($@) {
        fatal_error("missing filesystems.yaml (DiskConfig failed?)");
    }
    bless { cfg => $cfg, fs => $fs, proc => $proc }, $class;
}

sub _mkinitrd {
    my $self = shift;
    my ( $initrd, $version ) = @_;
    run_local("chroot /mnt /sbin/mkinitrd -f $initrd $version");
}

sub boot_mountpoint {
    my $self    = shift;
    my $fs      = $self->{fs};
    if( $fs->{'/boot'} ) {
        return '/boot';
    } else {
        return '/';
    }
}

sub boot_part {
    my $self    = shift;
    my $fs      = $self->{fs};
    my $boot_fs = $fs->{'/boot'} || $fs->{'/'};
    my $part    = $boot_fs->{'part_nr'};
    return $part - 1;
}

sub boot_device {
    my $self    = shift;
    my $fs      = $self->{fs};
    my $boot_fs = $fs->{'/boot'} || $fs->{'/'};
    my $disk    = $boot_fs->{'disk'};
    my $dev     = "/dev/" . $disk;
    return $dev;
}

sub root_device {
    my $self = shift;
    my $fs   = $self->{fs};
    my $dev  = "/dev/" . $fs->{'/'}{'phys'};
    return $dev;
}

# write device.map
sub devices {
    my $self        = shift;
    my $boot_device = $self->boot_device;
    my $contents    = "# this device map was generated by sysbuilder\n"
        . "(hd0)  $boot_device\n";

    write_file( "/mnt/boot/grub/device.map", $contents );

}

sub os_release {
    my $self = shift;
    return $self->{_release} if $self->{_release};

    my $release;
    if ( -e "/mnt/etc/vmware-release" ) {
        $release = read_file("/mnt/etc/vmware-release");
    }
    else {
        $release = read_file("/mnt/etc/redhat-release");
    }

    $self->{_release} = $release;
    return $release;
}

sub get_kernels {
    my $self     = shift;
    my @packages = backtick("chroot /mnt rpm -qa");
    my @kernels
        = grep { /\Akernel/ && !/(?:devel|headers|utils|source|firmware)/ } @packages;
    chomp(@kernels);
    my @res;

    my %extra = (
        ''        => '-up',
        'smp'     => '',
        'largesmp'=> '',
        'hugemem' => '-huge',
        'PAE'     => '-PAE',
        'xen'     => '-Xen',
        'vmnix'   => '-vmnix',
    );

    my $release_file = $self->os_release;
    my $release      = "Kernel";
    if ( $release_file =~ /\A(.*) release/ ) {
        $release = $1;
    }

    for (@kernels) {
        unless (/\Akernel(-smp|-largesmp|-hugemem|-xen|-PAE|-vmnix)?-([-\d.a-zA-Z_]+)\z/)
        {
            fatal_error("kernel name: $_ - can't parse");
        }
        my ( $type, $version ) = ( $1, $2 );
        if ($type) {
            $type =~ s/\A-//;
        }
        else {
            $type = "";
        }

        my $extra_title = $extra{$type};
        if ( $extra_title eq '-up' and $version =~ /2\.6\.18/ ) {
            $extra_title = '';    # RHEL5 EL kernel does SMP and UP
        }
        push @res,
            {
            title   => "$release$extra_title ($version$type)",
            kernel  => "/vmlinuz-$version$type",
            initrd  => "/initrd-$version$type.img",
            version => "$version$type",
            };
    }

    return @res;
}

sub console {
    my $self    = shift;
    my $console = SysBuilder::Console->new;
    return $console->boot_console( $self->{cfg} );
}

sub serial_settings {
    my $self    = shift;
    my $console = SysBuilder::Console->new;
    my ( $port, $speed ) = $console->boot_serial_settings( $self->{cfg} );
    return unless defined $port;
    return ( $port, $speed );
}

sub _default_kernel_idx {
    my ( $self, $kernels, $preferred, $cpus ) = @_;

    my $idx = 0;
    my $fallback = -1;
    my $smp = "";
    if ( $cpus > 1 && $cpus <= 8 ) {
         $smp = "smp";
    } elsif ( $cpus > 8 ) {
        $smp = "largesmp";
    }

    for my $k (@$kernels) {
        if ($preferred) {
            return $idx if $k->{version} =~ /$preferred/;
        }
        else {
           # RHEL 4: smp is the default
           # RHEL 5: up and smp were merged. so el is the default
           if( $k->{version} =~ /\A 2 \. 6 \. (?: 9-.*$smp 
                                                | 18-\d+((\.\d+)?)+\.el5(\..*)?
                                                | 32-\d+((\.\d+)?)+\.el6(\..*)?
                                               )\z/msx 
             ) {
               return $idx;

           # edge case where the logic above may want to install the largesmp
           # kerel but the image may not have it. If the SMP kerel exists then
           # return that else still exit -1.        
           } elsif( $k->{version} =~ /\A 2 \. 6 \.9-.*smp\z/msx ) {
                $fallback = $idx;
           }                               
        }
        $idx++;
    } 
    return $fallback;
}    

sub default_kernel_version {
    my $self    = shift;
    my @kernels = $self->get_kernels;
    my $cfg     = $self->{cfg};
    my $cpus    = $self->{proc}->cpucount;
    my $idx
        = $self->_default_kernel_idx( \@kernels, $cfg->{kernel_version} || "",
        $cpus );
    croak "Can't get default kernel_version" if $idx < 0;

    return $kernels[$idx]->{version};
}

sub esx {
    my $uts_release = ( POSIX::uname() )[2];
    return ( $uts_release =~ /vmnix/ );
}

sub esx_grub_conf {
    my ( $self, %params ) = @_;

    my @config = @{ $params{config} };

    # for now just use their CLI

    # first we need to determine the UUID of the root partition
    my $root_device = $params{root_device};
    my $uuid_str = backtick("dumpe2fs $root_device | grep Filesystem.UUID");

    $uuid_str =~ /\AFilesystem \s UUID: \s+ (\S+)/msx;
    my $uuid    = $1;
    my $cmdline = $params{kernel_cmdline} . ' ' . $params{console};
    $cmdline =~ s/\A \s+//msx;
    $cmdline =~ s/\s+\z//msx;

    run_local("chroot /mnt esxcfg-boot -d UUID=$uuid -a '$cmdline'");
    run_local("chroot /mnt /usr/sbin/esxcfg-pciid -q --boot");
}

sub xen_version {
    my $self   = shift;
    my %params = ( dir => "/mnt/boot", @_ );
    my $dir    = $params{dir};

    my $cfg = $self->{cfg};

    return $cfg->{xen_version} if $cfg->{xen_version};
    my @xen = sort { $b cmp $a }
        map { s(.*/)(); $_ } glob("$dir/xen.gz*");
    return "" unless @xen;

    return $xen[0];
}

sub grub_conf {
    my $self          = shift;
    my $create_initrd = shift;

    my @config;
    push @config, <<'EOT';
# grub.conf generated by SysBuilder
#
# Note that you do not have to rerun grub after making changes to this file
#
EOT
    my $fs             = $self->{fs};
    my $cfg            = $self->{cfg};
    my $kernel_cmdline = $cfg->{kernel_cmdline} || "";
    my $kernel_version = $cfg->{kernel_version} || "";
    my $console        = $self->console;

    my $root_device = $self->root_device;
    my $boot_part   = $self->boot_part;
    my $boot        = "/boot";

    # if we have a /boot partition add a nice note
    if ( $fs->{'/boot'} ) {
        push @config, <<"EOT";
# NOTICE:  You have a /boot partition. This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=$root_device
#          initrd /initrd-version
EOT
        $boot = "";
    }

    if ( $self->esx ) {
        $self->esx_grub_conf(
            kernel_cmdline => $kernel_cmdline,
            kernel_version => $kernel_version,
            console        => $console,
            root_device    => $root_device,
            boot_part      => $boot_part,
            boot           => $boot,
            config         => \@config,
        );
        return;
    }

    my @kernels = $self->get_kernels;
    my $cpus    = $self->{proc}->cpucount;
    my $default_kernel_idx
        = $self->_default_kernel_idx( \@kernels, $kernel_version, $cpus );
    if ( $default_kernel_idx < 0 ) {
        fatal_error("$kernel_version requested, but not installed");
    }

    # always use /boot/initrd, regardless of /boot partition
    if ($create_initrd) {
        foreach my $kernel (@kernels) {
            $self->_mkinitrd( "/boot" . $kernel->{initrd},
                $kernel->{version} );
        }
    }
    my $serial_or_splash;
    if ($console) {
        my ( $serial_port, $serial_speed ) = $self->serial_settings;
        unless ( $cfg->{grub_serial_disabled} ) {
            $serial_or_splash = <<EOT;
serial --unit=$serial_port --speed=$serial_speed --word=8 --parity=no --stop=1
terminal serial
EOT
        }
        else {
            $serial_or_splash = "";
        }
    }
    else {
        $serial_or_splash = "splashimage=(hd0,$boot_part)/grub/splash.xpm.gz";
    }
    my $boot_md = "";
    my $boot_fs = $fs->{'/boot'} || $fs->{'/'};
    if ( $boot_fs->{phys} =~ /\A md /msx ) {
        $boot_md = "boot=/dev/" . $boot_fs->{phys};
    }
    push @config, <<"EOT";
$boot_md
default=$default_kernel_idx
timeout=5
$serial_or_splash
EOT

    if ( $self->is_a_vm ) {
        $kernel_cmdline .= " clock=pit";
    }
    $kernel_cmdline =~ s/\s+/ /g;

    my $xen = "/" . $self->xen_version;
    for my $k (@kernels) {
        my ( $title, $kernel, $initrd )
            = ( $k->{title}, $k->{kernel}, $k->{initrd} );
        if ( $kernel !~ /xen/ ) {
            push @config, <<"EOT";
title $title
    root (hd0,$boot_part)
    kernel $boot$kernel ro root=$root_device $kernel_cmdline $console
    initrd $boot$initrd
EOT
        }
        else {
            my ( $serial_port, $serial_speed ) = $self->serial_settings;
            my $com_port = $serial_port + 1;

            my $dom0_mem = $cfg->{dom0_mem} || '1G';
            # 0 vcpus actually allows xen to use all cpus for dom0
            my $dom0_vcpus = $cfg->{dom0_vcpus} || '0';
            push @config, <<"EOT";
title $title
    root (hd0,$boot_part)
    kernel $boot$xen dom0_mem=$dom0_mem dom0_max_vcpus=$dom0_vcpus console=com$com_port com$com_port=$serial_speed,8n1
    module $boot$kernel ro root=$root_device $kernel_cmdline $console
    module $boot$initrd
EOT
        }
    }

    return join( '', @config );
}

sub generate_grub_conf {
    my $self   = shift;
    my $config = $self->grub_conf(@_);
    unless ($config) {

        # it's expected that ESX tools take care of grub.conf
        # so $config should be empty
        unless ( $self->esx ) {
            print "WARNING: empty grub.conf\n";
        }
        return;
    }

    write_file( "/mnt/boot/grub/grub.conf", $config );
    chmod 0600, "/mnt/boot/grub/grub.conf";
}

sub is_a_vm {
    my $lspci = `lspci`;
    return $lspci =~ m/vmware/i;
}

sub config {
    my $self   = shift;
    my %params = @_;
    $self->devices;
    $self->generate_grub_conf( $params{create_initrd} );
}

sub install {
    my $self      = shift;
    my $boot_part = $self->boot_part;
    my $grub_flags;

    if ( $self->esx ) {
        $grub_flags = "";
    }
    else {
        $grub_flags = "--no-floppy";
    }

    print "INFO: Creating mtab in chroot environment\n";
    my $mtab = read_file('/etc/mtab');
    $mtab =~ s{/mnt/}{/}go;
    write_file( '/mnt/etc/mtab', $mtab );

    print "INFO: Installing the bootloader\n";
    my $err = run_local(qq(chroot /mnt grub-install $grub_flags '(hd0)'));
    if ($err) {
        print "INFO: grub-install failed. Trying to install grub manually\n";

        # grub-install seems confused, so let's install grub manually
        my $boot_mountpoint = $self->boot_mountpoint;
        my $grub_install
            = qq(echo "root (hd0,$boot_part)\nsetup (hd0)" | grub --device-map=$boot_mountpoint/grub/device.map);
        run_local(qq(chroot /mnt sh -c '$grub_install'));
    }
}

1;
